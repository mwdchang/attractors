<!DOCTYPE html>
<html>
<head>
<title>Attractors</title>
<!--<script src="TrackballControls.js"></script> -->
<script src="lorenz.js"></script>
<script src="dejong.js"></script>
<script src="rossler.js"></script>
<script src="barnsley.js"></script>
<script src="aizawa.js"></script>
<style>
body, p {
  margin: 0;
  font-family: Tahoma;
}

.control-panel {
  display: flex;
  position: absolute;
  flex-direction: column;
  top: 20px;
  right: 20px;
  background: #555;
  color: #ddd;
  opacity: 0.80;
  padding: 10px;
  border-radius: 4px;
  border: 1px solid #bcd;
  font-size: 14px;
  max-width: 20%;
}

#params {
  font-size: 80%;
  color: #ddd; 
}
</style>
</head>
<body>
<div class="control-panel">
  <div>
    <p> Mouse-drag to rotate the scene, mouse-wheel to zoom-in/zoom-out.</p>
  </div>
  <div><hr/></div>
  <div style="display: flex; gap: 10px">
    <label>Select attractor</label>
    <select style="flex-grow: 1"> 
      <option value="lorenz" selected>Lorenz</option>
      <option value="dejong">DeJong</option>
      <option value="rossler">Rossler</option>
      <option value="barnsley">Barnsley</option>
      <option value="aizawa">Aizawa</option>
    </select>
  </div>
  <pre id="params"> 
  </pre>
</div>
</body>
<script type="module">
import * as THREE from 'https://esm.sh/three@0.178.0';
import { 
  TrackballControls 
} from 'https://esm.sh/three@0.178.0/examples/jsm/controls/TrackballControls.js';


const W = window.innerWidth;
const H = window.innerHeight;

const projection = {
  angle: 45,
  aspect: W / H,
  near: 0.1,
  far: 10000
};

const container = document.querySelector('body');

const renderer = new THREE.WebGLRenderer();
renderer.setSize(W, H);
renderer.setPixelRatio( window.devicePixelRatio );
container.appendChild(renderer.domElement);


// Camera
const camera = new THREE.PerspectiveCamera(
  projection.angle,
  projection.aspect,
  projection.near,
  projection.far
);
camera.position.set( 50, 50, 200 );


const controls = new TrackballControls( camera, renderer.domElement );
controls.rotateSpeed = 2.0;
controls.zoomSpeed = 2.0;
controls.panSpeed = 0.8;
controls.noZoom = false;
controls.noPan = false;
controls.staticMoving = true;
controls.dynamicDampingFactor = 0.3;
controls.keys = [ 65, 83, 68 ];
controls.addEventListener( 'change', render );


const scene = new THREE.Scene();
scene.add(camera);


const radius = 50;
const segments = 16;
const rings = 16;

// Scene objects

// light
const pointLight = new THREE.PointLight(0xFFFFFF);
pointLight.position.x = 10;
pointLight.position.y = 50;
pointLight.position.z = 130;
scene.add(pointLight);

function vertexShader() {
  return `
    varying vec3 vUv; 
    attribute float lineDistance;
    varying float vLineDistance;

    void main() {
      vUv = position; 
      vLineDistance = lineDistance;
      vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
      gl_Position = projectionMatrix * modelViewPosition; 
    }
  `
}

function fragmentShader() {
  return `
    varying vec3 vUv;
    void main() {
      // gl_FragColor = vec4(vUv.x / vUv.y, vUv.y / vUv.z, vUv.z / vUv.x, 1.0);
      gl_FragColor = vec4(0.5, 0.6, 0.7, 1.0);
    }
  `
}

const uniforms = {
  u_time: { value: 0.0 }
};
function fragmentShader2() {
  return `
    uniform float u_time;
    varying float vLineDistance;

    void main() {
      // Tweak these two 
      float speed = 0.05;
      float cycles = 800.0; 

      float t = fract(vLineDistance * cycles - u_time * speed);
      float blend = smoothstep(0.2, 0.8, t); // smoother transition
      vec3 orange = vec3(0.9, 0.5, 0.0);
      vec3 cyan = vec3(0.0, 0.5, 0.9);
      vec3 color = mix(orange, cyan, blend);
      gl_FragColor = vec4(color, 1.0);
    }
  `
}

const lineMaterial = new THREE.ShaderMaterial({
  vertexShader: vertexShader(),
  fragmentShader: fragmentShader2(),
  uniforms
});


let attractor; 
let attractorData;
let iterations;
let multiplier;
let drawCount = 0;

document.querySelector('select').addEventListener('change', () => {
  switchAttractor();
});

function switchAttractor() {
  const idx = document.querySelector('select').selectedIndex;
  const name = document.querySelector('select').options[idx].value;
  console.log('switching to ', name);

  if (attractorData) {
    scene.remove( attractorData );
  }

  switch(name) {
    case 'lorenz':
      attractor = new Lorenz(); break;
    case 'dejong':
      attractor = new DeJong(); break;
    case 'rossler':
      attractor = new Rossler(); break;
    case 'barnsley':
      attractor = new Barnsley(); break;
    case 'aizawa':
      attractor = new Aizawa(); break;
    default:
      attractor = new Lorenz();
  }
  document.getElementById("params").innerHTML = JSON.stringify(attractor.getParameters(), null, 2);

  // attractor = new Barnsley();
  attractorData = null;
  iterations = attractor.iterations;
  multiplier = attractor.multiplier;

  const SIZE = 100000;
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array( SIZE * 3 ); // 3 vertices per point
  geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

  const lineDistances = new Float32Array(SIZE);
  for (let i = 0; i < SIZE; i++) {
    lineDistances[i] = i / SIZE;
  }
  geometry.setAttribute('lineDistance', new THREE.BufferAttribute(lineDistances, 1));


  if (attractor.type === 'line') {
    attractorData = new THREE.Line( geometry,  lineMaterial);
  } else {
    attractorData = new THREE.Points( geometry,  
      new THREE.PointsMaterial({ color: '#3D5', opacity: 0.5, size: 0.5 })
    );
  }
  scene.add( attractorData );
  updatePositions();
}


const xPositions = new Float32Array([ -9999, 0, 0, 9999, 0, 0 ]);
const xGeometry = new THREE.BufferGeometry();
xGeometry.setAttribute('position', new THREE.BufferAttribute(xPositions, 3));
scene.add(new THREE.Line(xGeometry, new THREE.LineBasicMaterial({ color: '#F88' })));

const yPositions = new Float32Array([ 0, -9999, 0, 0,  9999, 0 ]);
const yGeometry = new THREE.BufferGeometry();
yGeometry.setAttribute('position', new THREE.BufferAttribute(yPositions, 3));
scene.add(new THREE.Line(yGeometry, new THREE.LineBasicMaterial({ color: '#8F8' })));

const zPositions = new Float32Array([ 0, 0, -9999, 0, 0,  9999 ]);
const zGeometry = new THREE.BufferGeometry();
zGeometry.setAttribute('position', new THREE.BufferAttribute(zPositions, 3));
scene.add(new THREE.Line(zGeometry, new THREE.LineBasicMaterial({ color: '#88F' })));


function updatePositions() {
	const positions = attractorData.geometry.attributes.position.array;
  
  let index = 0;
  for (let i = 0; i < iterations; i++) {
    const pos = attractor.getPosition();
		positions[ index++ ] = multiplier * pos.x;
		positions[ index++ ] = multiplier * pos.y;
		positions[ index++ ] = multiplier * pos.z;
    attractor.next();
  }
}


function render() {
  renderer.render(scene, camera);
}

function animate(time) {
  // update uniform
  uniforms.u_time.value = time / 80; // time in seconds

	requestAnimationFrame( animate );
	controls.update();

	drawCount = ( drawCount + 20 ) % iterations;
	// line.geometry.setDrawRange( 0, drawCount );
	attractorData.geometry.setDrawRange( 0, drawCount );

	if ( drawCount === 0 ) {
		// periodically, generate new data
    attractor.reset(true);
    document.getElementById("params").innerHTML = JSON.stringify(attractor.getParameters(), null, 2);

		updatePositions();
		attractorData.geometry.attributes.position.needsUpdate = true; // required after the first render
	}
  render();
}


switchAttractor();
animate();
</script>
</html>
