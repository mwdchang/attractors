<!DOCTYPE html>
<html>
<head>
<title>Attractors</title>
<script src="three.min.js"></script>
<script src="TrackballControls.js"></script>
<script src="lorenz.js"></script>
<style>
body {
  margin: 0;
}
</style>
</head>
<body>
</body>
<script>
const W = window.innerWidth;
const H = window.innerHeight;

const projection = {
  angle: 45,
  aspect: W / H,
  near: 0.1,
  far: 10000
};

const container = document.querySelector('body');

const renderer = new THREE.WebGLRenderer();
renderer.setSize(W, H);
renderer.setPixelRatio( window.devicePixelRatio );
container.appendChild(renderer.domElement);


// Camera
const camera = new THREE.PerspectiveCamera(
  projection.angle,
  projection.aspect,
  projection.near,
  projection.far
);
camera.position.set( 0, 0, 200 );


const controls = new THREE.TrackballControls( camera, renderer.domElement );
controls.rotateSpeed = 2.0;
controls.zoomSpeed = 2.0;
controls.panSpeed = 0.8;
controls.noZoom = false;
controls.noPan = false;
controls.staticMoving = true;
controls.dynamicDampingFactor = 0.3;
controls.keys = [ 65, 83, 68 ];
controls.addEventListener( 'change', render );


const scene = new THREE.Scene();
scene.add(camera);


const radius = 50;
const segments = 16;
const rings = 16;

// Scene objects

// light
const pointLight = new THREE.PointLight(0xFFFFFF);
pointLight.position.x = 10;
pointLight.position.y = 50;
pointLight.position.z = 130;
scene.add(pointLight);

function vertexShader() {
  return `
    varying vec3 vUv; 

    void main() {
      vUv = position; 

      vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
      gl_Position = projectionMatrix * modelViewPosition; 
    }
  `
}

function fragmentShader() {
  return `
    varying vec3 vUv;
    void main() {
      gl_FragColor = vec4(1.0, 0.5, 1.0, 1.0);
    }
  `
}

const lineMaterial = new THREE.ShaderMaterial({
  vertexShader: vertexShader(),
  fragmentShader: fragmentShader()
});



const lorenz = new Lorenz();

const MAX_POINTS = 5000;
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array( MAX_POINTS * 3 ); // 3 vertices per point
geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

let drawCount = 2;
geometry.setDrawRange( 0, drawCount );
const line = new THREE.Line( geometry,  lineMaterial);
scene.add( line );
updatePositions();


function updatePositions() {
	const positions = line.geometry.attributes.position.array;

  
  let index = 0;
  for (let i = 0; i < MAX_POINTS; i++) {
    const pos = lorenz.getPosition();
		positions[ index++ ] = pos.x;
		positions[ index++ ] = pos.y;
		positions[ index++ ] = pos.z;
    lorenz.next();
  }
 

  /*
	var x = y = z = index = 0;
	for ( var i = 0, l = MAX_POINTS; i < l; i ++ ) {
		positions[ index ++ ] = x;
		positions[ index ++ ] = y;
		positions[ index ++ ] = z;
		x += ( Math.random() - 0.5 ) * 30;
		y += ( Math.random() - 0.5 ) * 30;
		z += ( Math.random() - 0.5 ) * 30;
	}
  */
}



function render() {
  renderer.render(scene, camera);
}

function animate() {
	requestAnimationFrame( animate );
	controls.update();

	drawCount = ( drawCount + 1 ) % MAX_POINTS;
	// line.geometry.setDrawRange( 0, drawCount );
	line.geometry.setDrawRange( 0, drawCount );

	if ( drawCount === 0 ) {
		// periodically, generate new data
		updatePositions();
		line.geometry.attributes.position.needsUpdate = true; // required after the first render
	}
  render();
}

animate();

</script>
</html>
